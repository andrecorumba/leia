{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projeto LeIA","text":"<p>O LeIA \u00e9 uma aplica\u00e7\u00e3o que usa modelos de intelig\u00eancia artificial da openAI para transcri\u00e7\u00e3o de \u00e1udio e v\u00eddeo. Voc\u00ea pode transcrever novos arquivos ou consultar casos j\u00e1 transcritos.</p> <p>Reposit\u00f3rio em: https://github.com/andrecorumba/leia</p> <p>Documenta\u00e7\u00e3o em: https://andrecorumba.github.io/leia/</p>"},{"location":"#versao-do-python","title":"Vers\u00e3o do Python","text":"<p>Projeto implementado na vers\u00e3o 3.10.10.</p>"},{"location":"#principais-bibliotecas-usadas-no-projeto","title":"Principais Bibliotecas usadas no Projeto:","text":"<p>os: biblioteca usada para interagir com o sistema operacional, permitindo manipular caminhos de arquivos, diret\u00f3rios,  vari\u00e1veis \u200b\u200bde ambiente, etc.</p> <p>whisper: biblioteca usada para transcri\u00e7\u00e3o dos \u00e1udios e v\u00eddeos (https://github.com/openai/whisper)</p> <p>pandas: biblioteca usada para trabalhar com dados em formato de tabela, permitindo manipula\u00e7\u00e3o, limpeza, an\u00e1lise e visualiza\u00e7\u00e3o de dados.</p> <p>sqlite3: biblioteca usada para trabalhar com bancos de dados SQLite, que \u00e9 um banco de dados relacional incorporado amplamente utilizado.</p> <p>streamlit: biblioteca usada para criar aplicativos da web interativos para an\u00e1lise de dados e visualiza\u00e7\u00e3o de dados, permitindo que os usu\u00e1rios criem pain\u00e9is de controle e pain\u00e9is de an\u00e1lise de dados interativos. streamlit_option_menu: uma biblioteca adicional para streamlit que permite criar menus suspensos personalizados com v\u00e1rias op\u00e7\u00f5es.</p> <p>pydub: biblioteca usada para trabalhar com arquivos de \u00e1udio, permitindo manipula\u00e7\u00e3o, convers\u00e3o e edi\u00e7\u00e3o de arquivos de \u00e1udio de v\u00e1rias maneiras, incluindo cortar, mesclar e ajustar o volume.</p>"},{"location":"#requitos-importantes","title":"Requitos Importantes","text":"<p>\u00c9 necess\u00e1rio instalar na m\u00e1quina o aplicativo ffmpeg que serve para convers\u00e3o de v\u00e1rios tipos de \u00e1udios e \u00e9 requisito para uso da biblioteca whisper. Fa\u00e7a o download em: https://ffmpeg.org. No MacOS instalamos a vers\u00e3o 5.2 por meio do Homebrew: brew install ffmpeg.</p>"},{"location":"#logo","title":"Logo","text":"<p>A t\u00edrulo de curiosidade, o logo foi criado por intelig\u00eancia artificial DALL-E https://labs.openai.com/</p>"},{"location":"#imagem-docker","title":"Imagem Docker","text":"<p>Para baixar a imagem Docker \u00e9 necess\u00e1rio ter o Docker instalado e digitar o seguinte comando no terminal.</p> <p><code>docker pull andrecorumba/leia-docker</code></p>"},{"location":"users-guide/","title":"Guia do usu\u00e1rio","text":"<p>A LeIA \u00e9 uma aplica\u00e7\u00e3o para transcrever arquivos de \u00e1udio e v\u00eddeo usando modelos de reconhecimento de fala. A aplica\u00e7\u00e3o tem um menu lateral com as seguintes op\u00e7\u00f5es:</p> <ul> <li>Sobre</li> <li>\u00c1udio</li> <li>V\u00eddeo</li> <li>Zip</li> <li>Analisar</li> <li>Configura\u00e7\u00f5es</li> </ul> <p>Abaixo est\u00e1 um guia do usu\u00e1rio sobre como usar cada uma dessas op\u00e7\u00f5es.</p>"},{"location":"users-guide/#importante","title":"Importante","text":"<p>Na primeria vez que voc\u00ea processar uma transcri\u00e7\u00e3o ela pode demorar mais do que as seguintes, pois o modelo de aprendizado de m\u00e1quina \u00e9 baixado nesta primeira vez.</p>"},{"location":"users-guide/#os-tokens","title":"Os Tokens","text":"<p>Os tokens s\u00e3o de suma import\u00e2ncia, pois permitem que voc\u00ea acesse e baixe as transcri\u00e7\u00f5es. Ademais, apenas com o token voc\u00ea pode apagar as transcri\u00e7\u00f5es e arquivos de \u00e1udio utilizados.</p>"},{"location":"users-guide/#sobre","title":"Sobre","text":"<p>Esta op\u00e7\u00e3o mostra informa\u00e7\u00f5es sobre a aplica\u00e7\u00e3o.</p>"},{"location":"users-guide/#audio","title":"\u00c1udio","text":"<p>Esta op\u00e7\u00e3o permite que voc\u00ea fa\u00e7a o upload de arquivos de \u00e1udio e transcreva seu conte\u00fado em texto.</p> <p>Clique na op\u00e7\u00e3o \"\u00c1udio\" no menu lateral. Selecione um ou mais arquivos de \u00e1udio para transcrever. Os tipos de arquivo aceitos s\u00e3o opus, wav, mp3, ogg e wma. Clique no bot\u00e3o \"Transcrever\". Aguarde enquanto a transcri\u00e7\u00e3o \u00e9 processada. Isso pode levar algum tempo. Depois que a transcri\u00e7\u00e3o for conclu\u00edda, o texto transcrito ser\u00e1 exibido abaixo dos arquivos enviados. Copie e guarde o token exibido. Voc\u00ea precisar\u00e1 dele para acessar as transcri\u00e7\u00f5es mais tarde.</p>"},{"location":"users-guide/#video","title":"V\u00eddeo","text":"<p>Esta op\u00e7\u00e3o permite que voc\u00ea fa\u00e7a o upload de arquivos de v\u00eddeo e transcreva seu conte\u00fado em texto.</p> <p>Clique na op\u00e7\u00e3o \"V\u00eddeo\" no menu lateral. Selecione um ou mais arquivos de v\u00eddeo para transcrever. Os tipos de arquivo aceitos s\u00e3o mp4, m4a, avi, mov e wmv. Clique no bot\u00e3o \"Transcrever\". Aguarde enquanto a transcri\u00e7\u00e3o \u00e9 processada. Isso pode levar algum tempo. Depois que a transcri\u00e7\u00e3o for conclu\u00edda, o texto transcrito ser\u00e1 exibido abaixo dos arquivos enviados. Copie e guarde o token exibido. Voc\u00ea precisar\u00e1 dele para acessar as transcri\u00e7\u00f5es.</p>"},{"location":"users-guide/#zip","title":"Zip","text":"<p>Esta op\u00e7\u00e3o permite que voc\u00ea fa\u00e7a o upload de um arquivo ZIP contendo arquivos de \u00e1udio ou v\u00eddeo e transcreva o conte\u00fado desses arquivos em texto.</p> <p>Clique na op\u00e7\u00e3o \"Zip\" no menu lateral. Selecione um arquivo ZIP contendo arquivos de \u00e1udio ou v\u00eddeo para transcrever. O tipo de arquivo aceito \u00e9 zip. Clique no bot\u00e3o \"Transcrever\". Aguarde enquanto a transcri\u00e7\u00e3o \u00e9 processada. Isso pode levar algum tempo. Depois que a transcri\u00e7\u00e3o for conclu\u00edda, o texto transcrito ser\u00e1 exibido abaixo dos arquivos enviados. Copie e guarde o token exibido.  Voc\u00ea precisar\u00e1 dele para acessar as transcri\u00e7\u00f5es.</p>"},{"location":"users-guide/#analisar","title":"Analisar","text":"<p>Esta op\u00e7\u00e3o permite que voc\u00ea visualize as transcri\u00e7\u00f5es para um token espec\u00edfico.</p> <p>Clique na op\u00e7\u00e3o \"Analisar\" no menu lateral. Insira o token do conjunto de transcri\u00e7\u00f5es que deseja analisar. Clique em \"Analisar\". As transcri\u00e7\u00f5es ser\u00e3o exibidas abaixo do token inserido.</p>"},{"location":"users-guide/#configuracoes","title":"Configura\u00e7\u00f5es","text":"<p>Esta op\u00e7\u00e3o permite que voc\u00ea remova transcri\u00e7\u00f5es antigas.</p>"},{"location":"api/about/","title":"About","text":""},{"location":"api/about/#app.about.about","title":"<code>about()</code>","text":"<p>Traz informa\u00e7\u00f5es sobre o projeto Leia.</p> Source code in <code>app/about.py</code> <pre><code>def about():\n'''\n    Traz informa\u00e7\u00f5es sobre o projeto Leia.\n    '''\n\n    st.image('./images/logo.png', width=200)\n    with open('./README.md') as f:\n        readme = f.read()\n    st.markdown(readme, unsafe_allow_html=True)\n</code></pre>"},{"location":"api/analize/","title":"Analize","text":""},{"location":"api/analize/#app.analize.analize","title":"<code>analize(token, database_folder_path, temporary_folder_path, original_folder_path)</code>","text":"<p>Consulta os casos cadastrados.  A fun\u00e7\u00e3o \u00e9 chamada no arquivo app.py e apresenta na tela o resultado da consulta.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de acesso ao banco de dados.</p> required <code>database_folder_path</code> <code>str</code> <p>Caminho para a pasta onde est\u00e3o os bancos de dados.</p> required <code>temporary_folder_path</code> <code>str</code> <p>Caminho para a pasta tempor\u00e1ria.</p> required <code>original_folder_path</code> <code>str</code> <p>Caminho para a pasta onde est\u00e3o os arquivos originais.</p> required Source code in <code>app/analize.py</code> <pre><code>def analize(token, database_folder_path, temporary_folder_path, original_folder_path):\n\n'''\n    Consulta os casos cadastrados. \n    A fun\u00e7\u00e3o \u00e9 chamada no arquivo app.py e apresenta na tela o resultado da consulta.\n\n    Parameters:\n        token (str): Token de acesso ao banco de dados.\n        database_folder_path (str): Caminho para a pasta onde est\u00e3o os bancos de dados.\n        temporary_folder_path (str): Caminho para a pasta tempor\u00e1ria.\n        original_folder_path (str): Caminho para a pasta onde est\u00e3o os arquivos originais.\n\n    '''      \n    if os.path.isfile(os.path.join(database_folder_path, token)):\n\n        try:\n\n            # Connect to database\n            conn = sqlite3.connect(os.path.join(database_folder_path, token))\n            query = f'SELECT * FROM transcripts'\n            df = pd.read_sql(query, conn)\n\n            # Show dataframe\n            st.dataframe(df) \n\n            # Download dataframe\n            st.download_button(label=\"Baixar CSV\", \n                                data=df.to_csv(sep=';', encoding='utf-8', index=False),\n                                file_name=f'LeIA_{token}.csv', \n                                mime='text/csv')\n\n            # Play audio\n            file_selected = st.selectbox(\"Selecione o arquivo para ouvir o \u00e1udio\", df['arquivo'])\n\n\n            mp3_audio_file = audio_formats.to_mp3(file_selected, original_folder_path, temporary_folder_path)\n\n\n            # Play audio\n            audio_bytes = open(os.path.join(temporary_folder_path, mp3_audio_file), 'rb').read()\n            st.audio(audio_bytes)\n\n\n            # Close connection\n            conn.close()\n\n        except Exception as e:\n\n            st.error(\"Erro ao acessar os dados.\")    \n\n    else:\n\n            st.error(\"N\u00e3o foi poss\u00edvel acessar o banco de dados. Verifique se o Token est\u00e1 correto e tente novamente.\")       \n</code></pre>"},{"location":"api/app_docker/","title":"App docker","text":""},{"location":"api/app_docker/#app.app_docker.main","title":"<code>main()</code>","text":"<p>App Vers\u00e3o Docker. Inicia o menu lateral e as p\u00e1ginas. Interface do usu\u00e1rio.  O menu lateral \u00e9 criado com a fun\u00e7\u00e3o option_menu do pacote streamlit_option_menu. As p\u00e1ginas s\u00e3o chamadas a partir da op\u00e7\u00e3o selecionada no menu lateral.</p> Source code in <code>app/app_docker.py</code> <pre><code>def main(): \n'''\n    App Vers\u00e3o Docker. Inicia o menu lateral e as p\u00e1ginas. Interface do usu\u00e1rio. \n    O menu lateral \u00e9 criado com a fun\u00e7\u00e3o option_menu do pacote streamlit_option_menu.\n    As p\u00e1ginas s\u00e3o chamadas a partir da op\u00e7\u00e3o selecionada no menu lateral.\n    '''\n\n    main_folder_path = \"etc\"\n\n    # Side Menu\n    with st.sidebar:   \n        option = option_menu(\"Vers\u00e3o Docker v.1.0.0\", \n                         options=[\"Sobre\", \n                                  \"\u00c1udio\",\n                                  \"V\u00eddeo\",\n                                  \"Zip\",\n                                  \"Analisar\",\n                                  \"Configura\u00e7\u00f5es\"],\n\n                         # Icons from https://icons.getbootstrap.com/\n                         icons=['house',\n                                'file-earmark-music-fill',\n                                'file-play-fill',\n                                'file-zip-fill',\n                                'binoculars',\n                                'wrench'],\n                         menu_icon=\"cloud\", default_index=0,\n        )   \n\n    # Pages\n    if option == 'Sobre': \n        about.about()\n\n\n    # Option Transcribe Files\n    elif option == \"\u00c1udio\" or option == \"V\u00eddeo\" or option == \"Zip\":  \n        st.subheader('Transcrever Arquivos')   \n        type_model = settings.select_model('docker')\n\n        # Only audio files\n        if option == \"\u00c1udio\":     \n            uploaded_file_list = st.file_uploader('Selecione os arquivos de \u00e1udio', \n                                                    type=[\"opus\",\"wav\",\"mp3\",\"ogg\",\"wma\"],\n                                                    accept_multiple_files=True)\n        # Only video files\n        elif option == \"V\u00eddeo\":     \n            uploaded_file_list = st.file_uploader('Selecione os arquivos de v\u00eddeo', \n                                                    type=[\"mp4\", \"m4a\", \"avi\", \"mov\", \"wmv\"],\n                                                    accept_multiple_files=True)\n\n        # Only zip files\n        elif option == \"Zip\":\n            uploaded_file_list = st.file_uploader('Selecione os arquivos de \u00e1udio ou v\u00eddeo', \n                                            type=[\"zip\", \"ufed\"],\n                                            accept_multiple_files=False)\n\n        # Check if files were uploaded\n        if uploaded_file_list is not None:\n            if st.button('Transcrever'):\n                # Create token\n                token = token_leia.get_token_leia()\n\n                # Crate token folders\n                token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.create_folders(token, main_folder_path)\n\n                if option == \"Zip\":     \n                    with open(os.path.join(temporary_folder_path, \n                                           uploaded_file_list.name), \"wb\") as f:\n\n                        f.write((uploaded_file_list).getbuffer())\n\n                    zip_file_list = extract_zip.extract_media_files(os.path.join(temporary_folder_path, \n                                                                                 uploaded_file_list.name), \n                                                                                 original_folder_path)\n\n                    #st.write(zip_file_list)\n\n                else:\n                    for file in uploaded_file_list:\n                        # Save all files with original name\n                        with open(os.path.join(original_folder_path, file.name),\"wb\") as f:\n                            f.write((file).getbuffer())\n\n                # Transcribe folder\n                with st.spinner(f\"Transcrevendo Arquivos ... \ud83d\udcab\"):\n                    # Transcribe file list\n                    df = pd.DataFrame(transcribe.transcribe(original_folder_path, type_model))\n                    st.dataframe(df)\n\n                    # Write to database           \n                    database.write_to_db(database_folder_path, token, df)\n\n                    # Print Token\n                    st.title(\"IMPORTANTE \u26a0\ufe0f\")\n                    st.subheader(f\"Copie e GUARDE o Token a Seguir. \") \n                    st.text(\"Voc\u00ea precisar\u00e1 dele para acessar as transcri\u00e7\u00f5es.\")\n                    st.code(token)\n                    st.markdown(\"O Token \u00e9 um c\u00f3digo \u00fanico que identifica essa trasncri\u00e7\u00e3o.\" \n                            \"Ele \u00e9 gerado automaticamente e \u00e9 \u00fanico para cada conjunto de transcri\u00e7\u00f5es.\" \n                            \"N\u00c3O O PERCA! Sem o Token, n\u00e3o ser\u00e1 poss\u00edvel acessar essas transcri\u00e7\u00f5es.\" \n                            \"Os arquivos de \u00e1udio e v\u00eddeo n\u00e3o s\u00e3o salvos no banco de dados.\"\n                            \"As transcri\u00e7\u00f5es ficam salvas no banco de dados por 30 dias.\"\n                            \"Ap\u00f3s esse per\u00edodo, os dados s\u00e3o apagados.\"\n                            \"Voc\u00ea pode acessar as transcri\u00e7\u00f5es a qualquer momento, basta inserir o Token no menu Analisar.\"\n                            \"Voc\u00ea poder\u00e1 apagar as transcri\u00e7\u00f5es a qualquer momento no menu Configura\u00e7\u00f5es.\"\n                            \"Acesse o menu Analisar ao lado e insira o token.\")\n\n    # Option Analize          \n    elif option == 'Analisar':\n        st.subheader('Analisar')\n        token = st.text_input(\"Informe o Token do caso que deseja analisar\")\n\n        # Check if token exists\n        if token:\n            token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.get_folders(token, main_folder_path)\n            analize.analize(token, database_folder_path, temporary_folder_path, original_folder_path)\n\n    # Option Settings\n    elif option == 'Configura\u00e7\u00f5es':\n\n        st.header('Configura\u00e7\u00f5es')\n\n        st.subheader(\"Remove Tokens\")\n        token = st.text_input(\"Informe o Token das trancri\u00e7\u00f5es que deseja remover\")\n\n        # Check if token exists\n        if token:    \n            # Check if like secrete token\n            if token == settings.read_secret_token('secret-token.txt'):\n                settings.install_models('docker')\n\n                if os.path.exists(main_folder_path):\n                    if st.button('Remover Todos os Tokens'):\n                        settings.remove_token(main_folder_path)\n\n            else:\n                try:\n                    token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.get_folders(token, main_folder_path)\n                    settings.remove_token(token_folder_path)\n                    st.success(\"Transcri\u00e7\u00f5es removidas com sucesso!\")\n\n                except:\n                    st.error(\"Token n\u00e3o encontrado. Verifique se o token est\u00e1 correto.\")\n</code></pre>"},{"location":"api/app_web/","title":"App web","text":""},{"location":"api/app_web/#app.app_web.main","title":"<code>main()</code>","text":"<p>Fun\u00e7\u00e3o principal do app. Inicia o menu lateral e as p\u00e1ginas. Interface do usu\u00e1rio.  O menu lateral \u00e9 criado com a fun\u00e7\u00e3o option_menu do pacote streamlit_option_menu. As p\u00e1ginas s\u00e3o chamadas a partir da op\u00e7\u00e3o selecionada no menu lateral.</p> Source code in <code>app/app_web.py</code> <pre><code>def main(): \n'''\n    Fun\u00e7\u00e3o principal do app. Inicia o menu lateral e as p\u00e1ginas. Interface do usu\u00e1rio. \n    O menu lateral \u00e9 criado com a fun\u00e7\u00e3o option_menu do pacote streamlit_option_menu.\n    As p\u00e1ginas s\u00e3o chamadas a partir da op\u00e7\u00e3o selecionada no menu lateral.\n    '''\n\n    main_folder_path = \"etc\"\n\n    # Side Menu\n    with st.sidebar:   \n        option = option_menu(\"Vers\u00e3o Web v.1.0.0\", \n                         options=[\"Sobre\", \n                                  \"\u00c1udio\",\n                                  \"V\u00eddeo\",\n                                  \"Zip\",\n                                  \"Analisar\",\n                                  \"Configura\u00e7\u00f5es\"],\n\n                         # Icons from https://icons.getbootstrap.com/\n                         icons=['house',\n                                'file-earmark-music-fill',\n                                'file-play-fill',\n                                'file-zip-fill',\n                                'binoculars',\n                                'wrench'],\n                         menu_icon=\"cloud\", default_index=0,\n        )   \n\n    # Pages\n    if option == 'Sobre': \n        about.about()\n\n\n    # Option Transcribe Files\n    elif option == \"\u00c1udio\" or option == \"V\u00eddeo\" or option == \"Zip\":  \n        st.subheader('Transcrever Arquivos')   \n        type_model = settings.select_model('web')\n\n        # Only audio files\n        if option == \"\u00c1udio\":     \n            uploaded_file_list = st.file_uploader('Selecione os arquivos de \u00e1udio', \n                                                    type=[\"opus\",\"wav\",\"mp3\",\"ogg\",\"wma\"],\n                                                    accept_multiple_files=True)\n        # Only video files\n        elif option == \"V\u00eddeo\":     \n            uploaded_file_list = st.file_uploader('Selecione os arquivos de v\u00eddeo', \n                                                    type=[\"mp4\", \"m4a\", \"avi\", \"mov\", \"wmv\"],\n                                                    accept_multiple_files=True)\n\n        # Only zip files\n        elif option == \"Zip\":\n            uploaded_file_list = st.file_uploader('Selecione os arquivos de \u00e1udio ou v\u00eddeo', \n                                            type=[\"zip\", \"ufed\"],\n                                            accept_multiple_files=False)\n\n        # Check if files were uploaded\n        if uploaded_file_list is not None:\n            if st.button('Transcrever'):\n                # Create token\n                token = token_leia.get_token_leia()\n\n                # Crate token folders\n                token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.create_folders(token, main_folder_path)\n\n                if option == \"Zip\":     \n                    with open(os.path.join(temporary_folder_path, \n                                           uploaded_file_list.name), \"wb\") as f:\n\n                        f.write((uploaded_file_list).getbuffer())\n\n                    zip_file_list = extract_zip.extract_media_files(os.path.join(temporary_folder_path, \n                                                                                 uploaded_file_list.name), \n                                                                                 original_folder_path)\n\n                    #st.write(zip_file_list)\n\n                else:\n                    for file in uploaded_file_list:\n                        # Save all files with original name\n                        with open(os.path.join(original_folder_path, file.name),\"wb\") as f:\n                            f.write((file).getbuffer())\n\n                # Transcribe folder\n                with st.spinner(f\"Transcrevendo Arquivos ... \ud83d\udcab\"):\n                    # Transcribe file list\n                    df = pd.DataFrame(transcribe.transcribe(original_folder_path, type_model))\n                    st.dataframe(df)\n\n                    # Write to database           \n                    database.write_to_db(database_folder_path, token, df)\n\n                    # Print Token\n                    st.title(\"IMPORTANTE \u26a0\ufe0f\")\n                    st.subheader(f\"Copie e GUARDE o Token a Seguir. \") \n                    st.text(\"Voc\u00ea precisar\u00e1 dele para acessar as transcri\u00e7\u00f5es.\")\n                    st.code(token)\n                    st.markdown(\"O Token \u00e9 um c\u00f3digo \u00fanico que identifica essa trasncri\u00e7\u00e3o.\" \n                            \"Ele \u00e9 gerado automaticamente e \u00e9 \u00fanico para cada conjunto de transcri\u00e7\u00f5es.\" \n                            \"N\u00c3O O PERCA! Sem o Token, n\u00e3o ser\u00e1 poss\u00edvel acessar essas transcri\u00e7\u00f5es.\" \n                            \"Os arquivos de \u00e1udio e v\u00eddeo n\u00e3o s\u00e3o salvos no banco de dados.\"\n                            \"As transcri\u00e7\u00f5es ficam salvas no banco de dados por 30 dias.\"\n                            \"Ap\u00f3s esse per\u00edodo, os dados s\u00e3o apagados.\"\n                            \"Voc\u00ea pode acessar as transcri\u00e7\u00f5es a qualquer momento, basta inserir o Token no menu Analisar.\"\n                            \"Voc\u00ea poder\u00e1 apagar as transcri\u00e7\u00f5es a qualquer momento no menu Configura\u00e7\u00f5es.\"\n                            \"Acesse o menu Analisar ao lado e insira o token.\")\n\n    # Option Analize          \n    elif option == 'Analisar':\n        st.subheader('Analisar')\n        token = st.text_input(\"Informe o Token do caso que deseja analisar\")\n\n        # Check if token exists\n        if token:\n            token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.get_folders(token, main_folder_path)\n            analize.analize(token, database_folder_path, temporary_folder_path, original_folder_path)\n\n    # Option Settings\n    elif option == 'Configura\u00e7\u00f5es':\n\n        st.header('Configura\u00e7\u00f5es')\n\n        st.subheader(\"Remove Tokens\")\n        token = st.text_input(\"Informe o Token das trancri\u00e7\u00f5es que deseja remover\")\n\n        # Check if token exists\n        if token:    \n            # Check if like secrete token\n            if token == settings.read_secret_token('secret-token.txt'):\n                settings.install_models('web')\n\n                if os.path.exists(main_folder_path):\n                    if st.button('Remover Todos os Tokens'):\n                        settings.remove_token(main_folder_path)\n\n            else:\n                try:\n                    token_folder_path, database_folder_path, temporary_folder_path, original_folder_path = folders.get_folders(token, main_folder_path)\n                    settings.remove_token(token_folder_path)\n                    st.success(\"Transcri\u00e7\u00f5es removidas com sucesso!\")\n\n                except:\n                    st.error(\"Token n\u00e3o encontrado. Verifique se o token est\u00e1 correto.\")\n</code></pre>"},{"location":"api/audio_formats/","title":"Audio formats","text":""},{"location":"api/audio_formats/#app.audio_formats.to_mp3","title":"<code>to_mp3(file_selected, original_folder_path, temporary_folder_path)</code>","text":"<p>Transforma um arquivo de \u00e1udio ou v\u00eddeo em mp3.</p> <p>Parameters:</p> Name Type Description Default <code>file_selected</code> <code>str</code> <p>Nome do arquivo de \u00e1udio ou v\u00eddeo.</p> required <code>original_folder_path</code> <code>str</code> <p>Caminho da pasta de upload onde o arquivo est\u00e1.</p> required <code>temporary_folder_path</code> <code>str</code> <p>Caminho da pasta tempor\u00e1ria onde o arquivo ser\u00e1 salvo.</p> required <p>Returns:</p> Name Type Description <code>mp3_audio_file</code> <code>str</code> <p>Nome do arquivo em formato mp3.</p> Source code in <code>app/audio_formats.py</code> <pre><code>def to_mp3(file_selected, original_folder_path, temporary_folder_path):\n'''\n    Transforma um arquivo de \u00e1udio ou v\u00eddeo em mp3.\n\n    Parameters:\n        file_selected (str): Nome do arquivo de \u00e1udio ou v\u00eddeo.\n        original_folder_path (str): Caminho da pasta de upload onde o arquivo est\u00e1.\n        temporary_folder_path (str): Caminho da pasta tempor\u00e1ria onde o arquivo ser\u00e1 salvo.\n\n    Returns:\n        mp3_audio_file (str): Nome do arquivo em formato mp3.\n    '''\n\n    # Check if file is mp3\n    if os.path.splitext(file_selected)[1] != \".mp3\":\n\n        # Create mp3 file name\n        mp3_audio_file = file_selected.split('.')[0] + '.mp3'\n\n        # Convert to mp3\n        audio = AudioSegment.from_file(os.path.join(original_folder_path, file_selected))\n\n        # Save file in mp3 format to upload folder\n        audio.export(os.path.join(temporary_folder_path, mp3_audio_file), format=\"mp3\")\n\n    return mp3_audio_file \n</code></pre>"},{"location":"api/database/","title":"Database","text":""},{"location":"api/database/#app.database.write_to_db","title":"<code>write_to_db(database_folder_path, token, df)</code>","text":"<p>Recebe o nome do arquivo e o texto transcrito e salva no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>database_folder_path</code> <code>str</code> <p>Caminho da pasta onde o banco de dados est\u00e1.</p> required <code>token</code> <code>str</code> <p>Nome do caso.</p> required <code>df</code> <code>pandas.DataFrame</code> <p>Dataframe com os dados a serem salvos.</p> required Source code in <code>app/database.py</code> <pre><code>def write_to_db(database_folder_path, token, df):\n\n'''\n    Recebe o nome do arquivo e o texto transcrito e salva no banco de dados.\n\n    Parameters:\n        database_folder_path (str): Caminho da pasta onde o banco de dados est\u00e1.\n        token (str): Nome do caso.\n        df (pandas.DataFrame): Dataframe com os dados a serem salvos.\n    '''\n    table_name = 'transcripts'\n    # Create connection\n    conn = sqlite3.connect(os.path.join(database_folder_path, token))\n\n    try:        \n        df.to_sql(table_name, con=conn, if_exists='replace', index=False)\n        st.success(f\"Trancri\u00e7\u00e3o Gravada no Banco de Dados.\")\n\n    except Exception as e:\n        st.error(f\"Algo deu errado. N\u00e3o foi poss\u00edvel gravar no banco de dados.\")\n        st.error(e)\n\n    conn.close()\n</code></pre>"},{"location":"api/folders/","title":"Folders","text":""},{"location":"api/folders/#app.folders.create_folders","title":"<code>create_folders(token, main_folder_path)</code>","text":"<p>Cria as pastas necess\u00e1rias para o funcionamento da aplica\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token do usu\u00e1rio.</p> required <code>main_folder_path</code> <code>str</code> <p>Caminho da pasta principal.</p> required <p>Returns:</p> Name Type Description <code>token_folder_path</code> <code>str</code> <p>Caminho da pasta do token.</p> <code>database_folder_path</code> <code>str</code> <p>Caminho da pasta do banco de dados.</p> <code>temporary_folder_path</code> <code>str</code> <p>Caminho da pasta tempor\u00e1ria.</p> <code>original_folder_path</code> <code>str</code> <p>Caminho da pasta original.</p> Source code in <code>app/folders.py</code> <pre><code>def create_folders(token, main_folder_path):\n'''\n    Cria as pastas necess\u00e1rias para o funcionamento da aplica\u00e7\u00e3o.\n\n    Parameters:\n        token (str): Token do usu\u00e1rio.\n        main_folder_path (str): Caminho da pasta principal.\n\n    Returns:\n        token_folder_path (str): Caminho da pasta do token.\n        database_folder_path (str): Caminho da pasta do banco de dados.\n        temporary_folder_path (str): Caminho da pasta tempor\u00e1ria.\n        original_folder_path (str): Caminho da pasta original.\n    '''\n\n    # Create the main folder if it doesn't exist yet\n    if not os.path.exists(main_folder_path):\n        os.makedirs(main_folder_path)\n\n    # Paths to the token folder to be created\n    token_folder_path = os.path.join(main_folder_path, token)\n\n    # Paths to the subfolders to be created\n    database_folder_path = os.path.join(token_folder_path, \"database\")\n    temporary_folder_path = os.path.join(token_folder_path, \"temporary\")\n    original_folder_path = os.path.join(token_folder_path, \"original\")\n\n    # Create the subfolders if they don't exist yet\n    for subfolder_path in [database_folder_path, temporary_folder_path, original_folder_path]:\n        if not os.path.exists(subfolder_path):\n            os.makedirs(subfolder_path)\n\n    return token_folder_path, database_folder_path, temporary_folder_path, original_folder_path\n</code></pre>"},{"location":"api/folders/#app.folders.get_folders","title":"<code>get_folders(token, main_folder_path)</code>","text":"<p>' Retorna os caminhos das pastas necess\u00e1rias para o funcionamento da aplica\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token do usu\u00e1rio.</p> required <code>main_folder_path</code> <code>str</code> <p>Caminho da pasta principal.</p> required <p>Returns:</p> Name Type Description <code>token_folder_path</code> <code>str</code> <p>Caminho da pasta do token.</p> <code>database_folder_path</code> <code>str</code> <p>Caminho da pasta do banco de dados.</p> <code>temporary_folder_path</code> <code>str</code> <p>Caminho da pasta tempor\u00e1ria.</p> <code>original_folder_path</code> <code>str</code> <p>Caminho da pasta original.</p> Source code in <code>app/folders.py</code> <pre><code>def get_folders(token, main_folder_path):\n''''\n    Retorna os caminhos das pastas necess\u00e1rias para o funcionamento da aplica\u00e7\u00e3o.\n\n    Parameters:\n        token (str): Token do usu\u00e1rio.\n        main_folder_path (str): Caminho da pasta principal.\n\n    Returns:\n        token_folder_path (str): Caminho da pasta do token.\n        database_folder_path (str): Caminho da pasta do banco de dados.\n        temporary_folder_path (str): Caminho da pasta tempor\u00e1ria.\n        original_folder_path (str): Caminho da pasta original.\n    '''\n\n    # Get the main folder\n    token_folder_path = os.path.join(main_folder_path, token)\n\n    # Paths to the subfolders to be created\n    database_folder_path = os.path.join(token_folder_path, \"database\")\n    temporary_folder_path = os.path.join(token_folder_path, \"temporary\")\n    original_folder_path = os.path.join(token_folder_path, \"original\")\n\n    return token_folder_path, database_folder_path, temporary_folder_path, original_folder_path\n</code></pre>"},{"location":"api/settings/","title":"Settings","text":""},{"location":"api/settings/#app.settings.clean_folder","title":"<code>clean_folder(folder_path)</code>","text":"<p>Remove todos os arquivos tempor\u00e1rios usados pela aplica\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Caminho da pasta onde os arquivos tempor\u00e1rios est\u00e3o armazenados.</p> required Example <p>clean_folder('/uploads')</p> Source code in <code>app/settings.py</code> <pre><code>def clean_folder(folder_path):\n'''\n    Remove todos os arquivos tempor\u00e1rios usados pela aplica\u00e7\u00e3o.\n\n    Parameters:\n        folder_path (str): Caminho da pasta onde os arquivos tempor\u00e1rios est\u00e3o armazenados.\n\n    Example:\n        &gt;&gt;&gt; clean_folder('/uploads')\n    '''\n    with st.spinner(f\"Removendo arquivos tempor\u00e1rios...\"):\n        for filename in os.listdir(folder_path):\n            file_path = os.path.join(folder_path, filename)\n            try:\n                if os.path.isfile(file_path):\n                    os.unlink(file_path)\n            except Exception as e:\n                st.error(f\"Erro ao remover {file_path} devido a {e}\")\n</code></pre>"},{"location":"api/settings/#app.settings.install_models","title":"<code>install_models(app_type)</code>","text":"<p>Interface para o usu\u00e1rio ajustar as configura\u00e7\u00f5es da aplica\u00e7\u00e3o.</p> Source code in <code>app/settings.py</code> <pre><code>def install_models(app_type):\n''' \n    Interface para o usu\u00e1rio ajustar as configura\u00e7\u00f5es da aplica\u00e7\u00e3o.\n    '''\n    st.subheader('Instalar Modelos de Aprendizagem de M\u00e1quina')\n    type_model =  select_model(app_type)\n\n    if st.button('Instalar'):\n        with st.spinner(f\"Instalando modelo {type_model} ... \ud83d\udcab\"):\n            whisper.load_model(type_model)\n            st.success(f\"Modelo {type_model} instalado com sucesso!\")\n</code></pre>"},{"location":"api/settings/#app.settings.read_secret_token","title":"<code>read_secret_token(file_name)</code>","text":"<p>L\u00ea o token secreto a partir de um arquivo.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Caminho do arquivo do token secreto.</p> required Source code in <code>app/settings.py</code> <pre><code>def read_secret_token(file_name):\n'''\n    L\u00ea o token secreto a partir de um arquivo.\n\n    Parameters:\n        file_name (str): Caminho do arquivo do token secreto.\n    '''\n    with open(file_name, 'r') as f:\n        token = f.read().strip()\n    return token\n</code></pre>"},{"location":"api/settings/#app.settings.remove_token","title":"<code>remove_token(folder_path)</code>","text":"<p>Remove todos os arquivos tempor\u00e1rios usados pela aplica\u00e7\u00e3o por token.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Caminho da pasta onde os arquivos tempor\u00e1rios est\u00e3o armazenados.</p> required Source code in <code>app/settings.py</code> <pre><code>def remove_token(folder_path):\n'''\n    Remove todos os arquivos tempor\u00e1rios usados pela aplica\u00e7\u00e3o por token.\n\n    Parameters:\n        folder_path (str): Caminho da pasta onde os arquivos tempor\u00e1rios est\u00e3o armazenados.\n    '''\n\n    if os.listdir(folder_path):\n        shutil.rmtree(folder_path)\n        st.success(\"Pasta com Tokens removidas com sucesso!\")\n</code></pre>"},{"location":"api/settings/#app.settings.select_model","title":"<code>select_model(app_type)</code>","text":"<p>Interface para o usu\u00e1rio selecionar o modelo de aprendizagem de m\u00e1quina a ser usado na transcri\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>app_type</code> <code>str</code> <p>tipo do app 'web ou 'docker'</p> required <p>Returns:</p> Type Description <code>str</code> <p>Nome do modelo de aprendizagem de m\u00e1quina selecionado.</p> Source code in <code>app/settings.py</code> <pre><code>def select_model(app_type):   \n'''\n    Interface para o usu\u00e1rio selecionar o modelo de aprendizagem de m\u00e1quina a ser usado na transcri\u00e7\u00e3o.\n\n    Parameters:\n        app_type (str): tipo do app 'web ou 'docker'\n\n    Returns:\n        (str): Nome do modelo de aprendizagem de m\u00e1quina selecionado.\n    '''\n    if app_type == 'web':\n        models_available = ['tiny','base']\n    elif app_type == 'docker':\n        models_available = ['tiny','base', 'small', 'medium','large'] \n\n    # Type \n    type_model = st.select_slider(\"Selecione o modelo: Quanto maior, mais preciso, por\u00e9m mais lento na hora de transcrever. \", \n                                  models_available)\n    return type_model\n</code></pre>"},{"location":"api/token_leia/","title":"Token leia","text":""},{"location":"api/token_leia/#app.token_leia.get_token_leia","title":"<code>get_token_leia()</code>","text":"<p>Fun\u00e7\u00e3o que gera um token aleat\u00f3rio para identificar o caso de uso do app.</p> <p>Returns:</p> Name Type Description <code>Token</code> <code>str</code> <p>Token aleat\u00f3rio de 32 caracteres.</p> Source code in <code>app/token_leia.py</code> <pre><code>def get_token_leia():\n''' \n    Fun\u00e7\u00e3o que gera um token aleat\u00f3rio para identificar o caso de uso do app.\n\n    Returns:\n        Token (str): Token aleat\u00f3rio de 32 caracteres.\n    '''\n\n    return ''.join([choice(string.ascii_letters + string.digits) for i in range(32)])\n</code></pre>"},{"location":"api/transcribe/","title":"Transcribe","text":""},{"location":"api/transcribe/#app.transcribe.transcribe","title":"<code>transcribe(folder, type_model)</code>","text":"<p>Fun\u00e7\u00e3o que transcreve uma lista de arquivos de \u00e1udio ou v\u00eddeo.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>Caminho da pasta com os arquivos de \u00e1udio ou v\u00eddeo.</p> required <code>type_model</code> <code>str</code> <p>Tipo de modelo a ser utilizado na transcri\u00e7\u00e3o.</p> required <p>Returns:</p> Name Type Description <code>dic_transcribe</code> <code>dict</code> <p>Dicion\u00e1rio com o nome do arquivo e o texto transcrito.</p> Source code in <code>app/transcribe.py</code> <pre><code>def transcribe(folder, type_model):\n'''\n    Fun\u00e7\u00e3o que transcreve uma lista de arquivos de \u00e1udio ou v\u00eddeo.\n\n    Parameters:\n        folder (str): Caminho da pasta com os arquivos de \u00e1udio ou v\u00eddeo.\n        type_model (str): Tipo de modelo a ser utilizado na transcri\u00e7\u00e3o.\n\n    Returns:\n        dic_transcribe (dict): Dicion\u00e1rio com o nome do arquivo e o texto transcrito.\n    '''\n\n    # Load whisper model\n    model = whisper.load_model(type_model)\n\n    dic_transcribe = {'arquivo'     : [ ],\n                      'transcricao' : [ ]}\n\n    audio_file_extensions = (\".opus\",\".wav\",\".mp3\",\".ogg\",\".wma\",\n                             \".mp4\", \".m4a\", \".avi\", \".mov\", \".wmv\")\n\n\n    file_list = os.listdir(folder)\n\n    for file in file_list:\n\n        # Check if file is audio or video and not a hidden file\n        if not file.startswith(\".\") and file.lower().endswith(audio_file_extensions):\n            try:  \n                st.warning(f\"Transcrevendo {file}\")   \n\n                result =  model.transcribe(os.path.join(folder,file)) \n                dic_transcribe['arquivo'].append(file)\n                dic_transcribe['transcricao'].append(result['text'])\n\n                st.success(f\"Arquivo Transcrito: {file}\")\n\n            except Exception as e:\n                st.error(f\"Algo deu errado\")\n                st.error(e)\n\n    return dic_transcribe\n</code></pre>"}]}